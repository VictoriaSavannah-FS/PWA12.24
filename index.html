<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="styles.css" />
    <title>Module 3 | Pixi Pong | PixiJS</title>
  </head>
  <body>
    <h1>- Pixi Pong -</h1>
    <game id="game"></game>
    <!-- Load in the PixiJS -->
    <script src="https://pixijs.download/release/pixi.min.js"></script>
    <!-- Our ES6 code goes here as a type="module" -->
    <script type="module">
      //new PixiJS application instance
      const app = new PIXI.Application();
      /* Calling an asyncronous method on our PixiJS application|  "init" > initializes our display*/
      await app.init({
        // defined width and height measured in pixels
        backgroundColor: "black",
        width: 800,
        height: 800,
      });
      //Define HTMLElement in our DOM we want to show our game using a DOM helper
      document.getElementById("game").appendChild(app.canvas);
      /**
                   * Create a new graphic isntance: Handle the Rectangualr BOrders
                   * Top | Bottom | Left | Right
                   * https://pixijs.com/8.x/examples/graphics/simple
                  //  *   // Rectangle + line style 2
                    graphics.rect(350, 50, 100, 100);
                    graphics.fill(0xc34288);
                    graphics.stroke({ width: 10, color: 0xffbd01 });
                   */
      /*
                          1. create a new graphic instance: represents "cirlce" on the screen
                          2. Assign it  variable called "circle"
                          */
      function rectangleBorder(x, y, width, height, color) {
        const border = new PIXI.Graphics();
        border.beginFill(color);
        // params: x, y, width, height, color - pass arguments
        border.drawRect(x, y, width, height);
        border.endFill();
        // add/append border to hmtl
        app.stage.addChild(border);
        return border;

        // graphics.stroke({ width: 10, color: white });
      }
      // Creating the actual borders
      /** X-axis
       * Y-axis
       * Width
       * Height
       * color*/
      // Top Border - 800px-Wdth | 10px heiht| red =0xff0000
      const top = rectangleBorder(0, 0, 800, 10, 0xff0000);
      // Bottom Border:800pxwdth|10px|0X-axis|y-790|  0xffd700=goldenrod
      const bottom = rectangleBorder(0, 790, 800, 10, 0xffd700);
      //Left Border: height: 790 | 0x00ff00=green
      const left = rectangleBorder(0, 0, 10, 790, 0x00ff00);

      // Right Borderconst: h:800 | 10w | x-s| y end | 0x0000ff = blue
      const right = rectangleBorder(790, 0, 10, 800, 0x0000ff);
      // circle --------------------------

      const circle = new PIXI.Graphics();
      //Set "fill" color - orange
      circle.beginFill("whitesmoke");
      /* Tell Pixi to draw an actual circle
                        > Three arguments| all measured in pixels.
                          > X,
                          > Y
                          > Radius size
                          */

      circle.drawCircle(0, 0, 8);
      // Now we need to call an end to our "fill" that we started
      // earlier with our "beginFill" call with the "endFill" call
      circle.endFill();
      /* Now we need to tell our circle where to "spawn" on our
                         game display by setting it's "view" x and y coordinates*/
      circle.x = 450;
      circle.y = 350;
      // This will determine our circle's "velocity" and direction
      let xv = 1;
      let yv = 3;

      // addChild call  --> ADDS circle to the game Stage Display
      app.stage.addChild(circle);
      // Add a refresh engine that powers our graphic's movement.
      //use built-in "ticker" feature like so...
      // tracks all border hits - starts @ false / 0
      let borderHit = { top: false, bottom: false, left: false, right: false };
      /* PROMISE GOES here to actually hanlde the  Game Logic  ----------------------
             * > if | Conditoinals--> need to handle the border hits
             * > then ( resolvce)stops the ticker / diospalys the message | ap.ticker.starft() inside promise
             * >https://www.w3schools.com/js/js_promise.asp
             *Promise(executor: (resolve: (value: any) => void, reject: (reason?: any) => void) => void): Promise<any>
      A callback used to initialize the promise. This callback is passed two arguments:
      a resolve callback used to resolve the promise with a value or the result of another promise,
      and a reject callback used to reject the promise with a provided reason or error.
             */
      function gameLogicPromise() {
        return new Promise((resolve) => {
          app.ticker.add(() => {
            // All following code will be executed on every "frame" update/refresh
            // Lets move our circle's by their direction/velocity
            circle.x += xv;
            circle.y += yv;
            // ADD the trigger handlers for Border hits
            // https://developer.mozilla.org/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Bounce_off_the_walls
            // added varaible for circle radius to refernce
            const circleRadius = 8;
            // BORDER HITS | Logic / conditionals!! -----------
            // borderHit - Left
            if (circle.x - circleRadius <= 10) {
              /*  > This will flip a postitive number to a negative
                  > as well as a negative to positive
                  > "math of signs" property|two negatives equals a positive*/
              // sepearte hitborder logic

              if (!borderHit.left) {
                borderHit.left = true; // change the color
                left.clear(); // clear old color
                // start new fill/end fill--
                left.beginFill(0xffffff);
                left.drawRect(0, 0, 10, 800);
                left.endFill(); // end fill block
              }

              xv = -xv; //reverse velocity
            }
            // borderHit - Right
            if (circle.x + circleRadius >= 790) {
              // bodrder collision logic
              if (!borderHit.right) {
                borderHit.right = true;
                right.clear(); // clear old color
                // start new fill/end fill--
                right.beginFill(0xffffff);
                right.drawRect(790, 0, 10, 800);
                right.endFill(); // end fill block
              }

              xv = -xv; //reverse vel.
            }

            // BorderHits for Bttm and top
            if (circle.y - circleRadius <= 10) {
              if (!borderHit.top) {
                borderHit.top = true;
                top.clear(); // clear old color
                // start new fill/end fill--
                top.beginFill(0xffffff);
                top.drawRect(0, 0, 800, 10);
                top.endFill(); // end fill block
              }

              yv = -yv; //reverse Y velcity
            }
            if (circle.y + circleRadius >= 790) {
              // border clisoin Logic
              if (!borderHit.bottom) {
                borderHit.bottom = true;
                bottom.clear(); // clear old color
                // start new fill/end fill--
                bottom.beginFill(0xffffff);
                bottom.drawRect(0, 790, 800, 10);
                bottom.endFill(); // end fill block
              }

              yv = -yv;
            }
            // chwck ALL borders | HIT
            if (
              borderHit.top &&
              borderHit.bottom &&
              borderHit.left &&
              borderHit.right
            ) {
              // stop the ticker - stop game adn display message!
              // app.ticker.stop();
              // alert("Yay! All borders were HIt! Play Again!");
              resolve();
            }
          });
        });
      }

      /**
       * Once the circle has bounced off all four borders, the Promise should resolve, and an alert should pop up to notify the user that the application has completed.
       */

      gameLogicPromise().then(() => {
        app.ticker.stop();
        alert("Yay! All borders were HIt! Play Again!");
      });
      // Promise to handle border hits
    </script>
  </body>
</html>
